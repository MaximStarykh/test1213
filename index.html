<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Enhanced Timeline Card Game</title>
    <style>
        /* CSS Custom Properties for easy theming and accessibility */
        :root {
    --tg-theme-bg-color: var(--tg-theme-bg-color, #ffffff);
    --tg-theme-text-color: var(--tg-theme-text-color, #000000);
    --tg-theme-hint-color: var(--tg-theme-hint-color, #999999);
    --tg-theme-link-color: var(--tg-theme-link-color, #2481cc);
    --tg-theme-button-color: var(--tg-theme-button-color, #5288c1);
    --tg-theme-button-text-color: var(--tg-theme-button-text-color, #ffffff);
}

        /* Global Reset and Base Styles */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
    background-color: var(--tg-theme-bg-color);
    color: var(--tg-theme-text-color);
            font-family: 'Roboto', Arial, sans-serif;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow-x: hidden;
            line-height: 1.6;
        }

        /* Improved Game Container Layout */
        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 100%;
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
        }

        /* Enhanced Game Info Section */
        #game-info {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            align-items: center;
            font-size: 1.2rem;
            color: var(--text-color);
            margin-bottom: 20px;
            padding: 15px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            box-shadow: var(--card-shadow);
        }

        #game-info>div {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        #game-info .icon {
            font-size: 1.8em;
            margin-bottom: 5px;
        }

        #lives {
            display: flex;
            gap: 5px;
        }

        /* Improved Timeline Section */
        #timeline {
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow-x: auto;
            padding: 20px;
            background: var(--timeline-gradient);
            border-radius: 10px;
            position: relative;
            white-space: nowrap;
            -webkit-overflow-scrolling: touch;
            scroll-snap-type: x mandatory;
            margin-bottom: 20px;
            width: 99%;
        }

        #timeline:only-child {
            justify-content: center;
        }

        /* Enhanced Card Styles */
        .card {
            flex-shrink: 0;
            scroll-snap-align: center;
            width: 180px;
            height: 250px;
            margin: 0 10px;
            transition: transform 0.6s;
            transform-style: preserve-3d;
            position: relative;
            cursor: pointer;
            perspective: 1000px;
        }


        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }


        .card.flipped {
            transform: rotateY(180deg);
        }

        .card-front,
        .card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            background-color: var(--card-color);
        }

        .card-front {
            background-color: var(--card-color);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            text-align: center;
        }

        .card-back {
            background-color: var(--secondary-color);
            color: white;
            transform: rotateY(180deg);
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
        }


        .card-title {
            font-size: 1rem;
            font-weight: bold;
            text-align: center;
            margin-top: 5px;
            max-width: 100%;
            overflow-wrap: break-word;
            word-wrap: break-word;
            hyphens: auto;
            white-space: normal;
            line-height: 1.2;
            max-height: 3.6em;
            /* Allows for up to 3 lines */
            overflow: hidden;
        }

        .card-emoji {
            font-size: 4rem;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-grow: 1;
        }

        .card-year {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 5px;
            color: #4CAF50;
            margin-top: auto;

        }

        .card-notice {
            font-size: 0.9rem;
            line-height: 1.4;
            text-align: center;
            width: 100%;
            height: 100%;
            overflow-y: auto;
            white-space: normal;
            word-wrap: break-word;
            padding: 10px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .card:active {
            transform: scale(1.05);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }

        /* Current Card Styles */
        #current-card {
            align-self: center;
            margin-bottom: 20px;
            cursor: grab;
        }

        #current-card:active {
            cursor: grabbing;
        }

        /* Improved Draw Card Button Styles */
        #draw-card {
    background-color: var(--tg-theme-button-color);
    color: var(--tg-theme-button-text-color);
            border: none;
            padding: 15px 30px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
            margin: 15px auto;
            border-radius: 25px;
            box-shadow: var(--button-shadow);
            display: block;
            width: 200px;
        }

        #draw-card:hover {
            background-color: #45a049;
        }

        #draw-card:active {
            transform: scale(0.98);
        }

        #draw-card:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }

        /* Card Animation Classes */
        .card.sliding-left {
            margin-right: 95px;
        }

        .card.sliding-right {
            margin-left: 95px;
        }

        .card.correct {
            box-shadow: 0 0 20px var(--secondary-color);
            animation: pulseGreen 0.5s;
        }

        .card.incorrect {
            box-shadow: 0 0 20px var(--incorrect-color);
            animation: pulseRed 0.5s;
        }

        /* Improved Feedback Styles */
        #feedback {
            position: fixed;
            right: 20px;
            top: 20px;
            font-size: 2rem;
            z-index: 1000;
            background-color: var(--card-color);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: none;
            justify-content: center;
            align-items: center;
            box-shadow: var(--card-shadow);
        }

        /* Game End Modal */
        #game-end-modal {
            display: none;
            position: fixed;
            z-index: 1001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
        }

        .modal-content {
            background-color: var(--card-color);
            margin: 15% auto;
            padding: 20px;
            border-radius: 10px;
            box-shadow: var(--card-shadow);
            width: 80%;
            max-width: 400px;
            text-align: center;
        }

        #restart-game {
            margin-top: 20px;
            padding: 10px 20px;
            background-color: var(--secondary-color);
            color: var(--primary-color);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
        }

        /* Keyframe Animations */
        @keyframes pulseGreen {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1);
            }
        }

        @keyframes pulseRed {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1);
            }
        }

        /* Improved Media Queries for Responsiveness */
        @media (max-width: 768px) {
            #game-info {
                font-size: 0.9rem;
                padding: 10px;
            }

            #game-info .icon {
                font-size: 1.2em;
            }

            .card {
                width: 150px;
                height: 200px;
            }

            .card-title {
                font-size: 0.9rem;
            }

            .card-year {
                font-size: 1rem;
            }

            .card-emoji {
                font-size: 3rem;
            }

            .card-notice {
                font-size: 0.8rem;
            }

            #timeline {
                padding: 10px;
            }

            #current-card {
                margin-bottom: 10px;
            }

            #draw-card {
                padding: 10px 20px;
                font-size: 1rem;
                width: 150px;
            }


        }

        /* Accessibility Improvements */
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            margin: -1px;
            padding: 0;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Focus styles for keyboard navigation */
        .card:focus,
        #draw-card:focus,
        #restart-game:focus {
            outline: 3px solid #4a90e2;
            outline-offset: 2px;
        }
    </style>
</head>

<body>
    <div id="game-container">
        <div id="game-info" aria-live="polite">
            <div>
                <span class="icon" aria-hidden="true">üèÜ</span>
                <span id="score">0</span>
                <span class="visually-hidden">Score:</span>
            </div>
            <div>
                <span id="lives" aria-label="Lives remaining">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span>
            </div>
            <div>
                <span class="icon" aria-hidden="true">üìä</span>
                <span id="progress">1/10</span>
                <span class="visually-hidden">Progress:</span>
            </div>
        </div>
        <div id="timeline" role="list" aria-label="Timeline of events">
            <div class="placement-indicator" aria-hidden="true"></div>
        </div>
        <div id="current-card" class="card" draggable="true" role="button" tabindex="0">
            <div class="card-inner">
                <div class="card-front">
                    <div class="card-title">Draw a card</div>
                    <div class="card-emoji" aria-hidden="true">üé¥</div>
                    <div class="card-year">to start!</div>
                </div>
                <div class="card-back">
                    <div class="card-notice">Draw a card to begin the game!</div>
                </div>
            </div>
        </div>
        <button id="draw-card" aria-label="Draw a new card">Draw Card</button>
        <div id="feedback" aria-live="assertive"></div>
    </div>
    <div id="game-end-modal" role="dialog" aria-modal="true" aria-labelledby="modal-title">
        <div class="modal-content">
            <h2 id="modal-title">Game Over</h2>
            <p id="modal-message"></p>
            <button id="restart-game">Restart Game</button>
        </div>
    </div>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script>
let tg = window.Telegram.WebApp;

// Initialize the Web App
tg.expand(); // Expand to full height
tg.ready(); // Notify Telegram that the Web App is ready

//  existing game variables and functions start here
let score = 0;
let lives = 3;
let progress = 0;
const totalCards = 10;
let availableEvents = [];
let mainButton = tg.MainButton;
tg.BackButton.onClick(restartGame);


mainButton.text = "Draw Card";
mainButton.onClick(drawCard);
mainButton.show();

        // DOM Elements
        const timeline = document.getElementById('timeline');
        const currentCard = document.getElementById('current-card');
        const drawCardButton = document.getElementById('draw-card');
        const scoreElement = document.getElementById('score');
        const livesElement = document.getElementById('lives');
        const progressElement = document.getElementById('progress');
        const placementIndicator = document.querySelector('.placement-indicator');
        const feedback = document.getElementById('feedback');
        const gameEndModal = document.getElementById('game-end-modal');
        const modalMessage = document.getElementById('modal-message');
        const restartGameButton = document.getElementById('restart-game');

        // Game events data
        const events = [
            { name: "Birth of Christ", year: 0, emoji: "üë∂", notice: "Marks the beginning of the Christian era. Celebrated as Christmas worldwide." },
            { name: "Fall of Rome", year: 476, emoji: "üèõÔ∏è", notice: "End of the Western Roman Empire. Marked the transition to the Middle Ages." },
            { name: "Discovery of America", year: 1492, emoji: "üö¢", notice: "Christopher Columbus reached the Americas. Led to European exploration and colonization." },
            { name: "French Revolution", year: 1789, emoji: "üá´üá∑", notice: "Overthrew the monarchy in France. Inspired democratic movements across Europe." },
            { name: "World War I Begins", year: 1914, emoji: "‚öîÔ∏è", notice: "Global conflict involving major powers. Reshaped international politics and borders." },
            { name: "Moon Landing", year: 1969, emoji: "üåô", notice: "Neil Armstrong became the first human on the moon. Marked a milestone in space exploration." },
            { name: "Fall of Berlin Wall", year: 1989, emoji: "üß±", notice: "Symbolized the end of the Cold War. Led to German reunification." },
            { name: "Internet Goes Public", year: 1991, emoji: "üåê", notice: "World Wide Web became publicly available. Revolutionized global communication and commerce." },
            { name: "9/11 Attacks", year: 2001, emoji: "üèôÔ∏è", notice: "Terrorist attacks on the United States. Led to global changes in security and foreign policy." },
            { name: "First iPhone Released", year: 2007, emoji: "üì±", notice: "Apple introduced the iPhone. Revolutionized mobile technology and communication." }
        ];

        // Initialize the game
        function initializeGame() {
            availableEvents = [...events];
            score = 0;
            lives = 3;
            progress = 0;
            updateGameInfo();
            clearTimeline();
            const randomIndex = Math.floor(Math.random() * availableEvents.length);
            const initialEvent = availableEvents.splice(randomIndex, 1)[0];
            const initialCard = createEventCard(initialEvent);
            initialCard.querySelector('.card-year').style.display = 'block';
            timeline.appendChild(initialCard);
            progress++;
            updateGameInfo();
            resetCurrentCard();
            drawCardButton.disabled = false;
            implementTouchDragDrop();
        }

        // Clear the timeline
        function clearTimeline() {
            while (timeline.firstChild) {
                timeline.removeChild(timeline.firstChild);
            }
            timeline.appendChild(placementIndicator);
        }

        // Update game information display
        function updateGameInfo() {
            scoreElement.textContent = score;
            livesElement.innerHTML = '‚ù§Ô∏è'.repeat(lives);
            progressElement.textContent = `${progress}/${totalCards}`;
        }

        // Draw a new card
        function drawCard() {
            if (availableEvents.length === 0) {
                endGame();
                return;
            }

            const randomIndex = Math.floor(Math.random() * availableEvents.length);
            const currentEvent = availableEvents.splice(randomIndex, 1)[0];

            currentCard.innerHTML = createEventCard(currentEvent, true).innerHTML;

            drawCardButton.disabled = true;
            currentCard.draggable = true;
            currentCard.setAttribute('aria-label', `Event card: ${currentEvent.name}. Drag to place on timeline.`);
            mainButton.hide();
            if (progress < totalCards) {
        mainButton.show();
    }
        }

        // At the start of the game
let initData = tg.initData || '';
let userId = tg.initDataUnsafe?.user?.id;

// Function to save game state
function saveGameState() {
    let gameState = {
        score: score,
        lives: lives,
        progress: progress,
        timeline: Array.from(timeline.children).map(card => card.textContent)
    };
    tg.CloudStorage.setItem('gameState', JSON.stringify(gameState));
}

// Function to load game state
function loadGameState() {
    tg.CloudStorage.getItem('gameState', function(err, value) {
        if (err) {
            console.error('Error loading game state:', err);
            return;
        }
        if (value) {
            let gameState = JSON.parse(value);
            score = gameState.score;
            lives = gameState.lives;
            progress = gameState.progress;
            // Reconstruct timeline
            clearTimeline();
            gameState.timeline.forEach(cardText => {
                let card = createEventCard({ name: cardText, year: '', emoji: '' });
                timeline.appendChild(card);
            });
            updateGameInfo();
        }
    });
}

// Call loadGameState at the start of your game
loadGameState();

        // Create a new event card
        function createEventCard(event, isCurrentCard = false) {
            const card = document.createElement('div');
            card.className = 'card';
            card.setAttribute('role', 'listitem');
            card.innerHTML = `
    <div class="card-front">
        <div class="card-title">${event.name}</div>
        <div class="card-emoji">${event.emoji}</div>
        <div class="card-year">${isCurrentCard ? '' : event.year}</div>
    </div>
    ${isCurrentCard ? '' : `
    <div class="card-back">
        <div class="card-notice">${event.notice}</div>
    </div>
    `}`;

            if (!isCurrentCard) {
                card.addEventListener('click', function () {
                    flipCard(this);
                });

                card.addEventListener('keydown', function (e) {
                    if (e.key === 'Enter' || e.key === ' ') {
                        flipCard(this);
                    }
                });
            }

            return card;
        }

        // Flip card function
        function flipCard(card) {
            card.classList.toggle('flipped');
            const isFrontVisible = !card.classList.contains('flipped');
            const cardContent = isFrontVisible ? card.querySelector('.card-front').textContent : card.querySelector('.card-back').textContent;
            card.setAttribute('aria-label', `Card ${isFrontVisible ? 'front' : 'back'}: ${cardContent}`);
        }

        // Handle drag start event
        function handleDragStart(e) {
            if (e.type === 'touchstart') return; // Ignore touch events here
            e.dataTransfer.setData('text/plain', e.target.id);
            setTimeout(() => (currentCard.style.opacity = '0.5'), 0);
        }

        // Handle drag end event
        function handleDragEnd() {
            currentCard.style.opacity = '1';
            placementIndicator.style.display = 'none';
            resetCardPositions();
        }

        // Handle drag over event
        function handleDragOver(e) {
            e.preventDefault();
            const afterElement = getDragAfterElement(timeline, e.clientX);
            updateCardPositions(afterElement);
            placementIndicator.style.display = 'block';
            if (afterElement) {
                timeline.insertBefore(placementIndicator, afterElement);
            } else {
                timeline.appendChild(placementIndicator);
            }
        }

        // Handle drag leave event
        function handleDragLeave() {
            placementIndicator.style.display = 'none';
        }

        // Handle drop event
        function handleDrop(e) {
            e.preventDefault();
            const id = e.dataTransfer ? e.dataTransfer.getData('text') : 'current-card';
            if (id === 'current-card') {
                const currentEvent = events.find(event => event.name === currentCard.querySelector('.card-title').textContent);
                const newCard = createEventCard(currentEvent);
                const afterElement = getDragAfterElement(timeline, e.clientX);

                if (afterElement) {
                    timeline.insertBefore(newCard, afterElement);
                } else {
                    timeline.appendChild(newCard);
                }

                const isCorrect = validateCardPlacement(newCard);
                if (isCorrect) {
                    newCard.querySelector('.card-year').style.display = 'block';
                    updateGameState(true);
                } else {
                    timeline.removeChild(newCard);
                    updateGameState(false);
                }
                resetCurrentCard();
            }
            placementIndicator.style.display = 'none';
            resetCardPositions();
        }

        function getDragAfterElement(container, x) {
            const draggableElements = [...container.querySelectorAll('.card:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = x - box.left - box.width / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // Get the element to insert the dragged card after
        function getDragAfterElement(container, x) {
            const draggableElements = [...container.querySelectorAll('.card:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = x - box.left - box.width / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // Update card positions during drag
        function updateCardPositions(afterElement) {
            const cards = timeline.querySelectorAll('.card');
            cards.forEach(card => card.classList.remove('sliding-left', 'sliding-right'));

            if (afterElement) {
                const previousElement = afterElement.previousElementSibling;
                if (previousElement && previousElement.classList.contains('card')) {
                    previousElement.classList.add('sliding-left');
                    afterElement.classList.add('sliding-right');
                } else {
                    afterElement.classList.add('sliding-right');
                }
            } else if (cards.length > 0) {
                cards[cards.length - 1].classList.add('sliding-left');
            }
        }

        // Reset card positions after drag
        function resetCardPositions() {
            const cards = timeline.querySelectorAll('.card');
            cards.forEach(card => {
                card.classList.remove('sliding-left', 'sliding-right');
            });
        }

        // Validate card placement
        function validateCardPlacement(newCard) {
            const cards = Array.from(timeline.querySelectorAll('.card'));
            const newCardIndex = cards.indexOf(newCard);
            const newCardYear = parseInt(newCard.querySelector('.card-year').textContent);

            if (newCardIndex === 0) {
                const nextCard = cards[1];
                return nextCard ? newCardYear <= parseInt(nextCard.querySelector('.card-year').textContent) : true;
            } else if (newCardIndex === cards.length - 1) {
                const prevCard = cards[cards.length - 2];
                return newCardYear >= parseInt(prevCard.querySelector('.card-year').textContent);
            } else {
                const prevCard = cards[newCardIndex - 1];
                const nextCard = cards[newCardIndex + 1];
                const prevCardYear = parseInt(prevCard.querySelector('.card-year').textContent);
                const nextCardYear = parseInt(nextCard.querySelector('.card-year').textContent);
                return newCardYear >= prevCardYear && newCardYear <= nextCardYear;
            }
        }

        // Update game state after card placement
        function updateGameState(isCorrect) {
            if (isCorrect) {
                showFeedback(true);
                score += 10;
            } else {
                showFeedback(false);
                lives--;
                if (lives <= 0) {
                    endGame();
                    return;
                }
            }

            progress++;
            updateGameInfo();

            if (progress === totalCards) {
                endGame();
            } else {
                drawCardButton.disabled = false;
            }
            saveGameState();
        }

        // Reset current card
        function resetCurrentCard() {
            currentCard.innerHTML = `
        <div class="card-inner">
            <div class="card-front">
                <div class="card-title">Draw a card</div>
                <div class="card-emoji">üé¥</div>
                <div class="card-year">to continue!</div>
            </div>
            <div class="card-back">
                <div class="card-notice">Draw a card to continue the game!</div>
            </div>
        </div>`;
            currentCard.draggable = false;
            currentCard.setAttribute('aria-label', 'Draw a new card to continue the game');
        }

        // Show feedback after card placement
        function showFeedback(isCorrect) {
            feedback.textContent = isCorrect ? '‚úÖ' : '‚ùå';
            feedback.className = isCorrect ? 'correct' : 'incorrect';
            feedback.style.display = 'flex';
            feedback.setAttribute('aria-label', isCorrect ? 'Correct placement' : 'Incorrect placement');
            setTimeout(() => {
                feedback.style.display = 'none';
            }, 1500);
            if (isCorrect) {
        tg.HapticFeedback.notificationOccurred('success');
    } else {
        tg.HapticFeedback.notificationOccurred('error');
    }
        }

        // End the game
        function endGame() {
            drawCardButton.disabled = true;
    const message = lives <= 0
        ? `Game Over! You've run out of lives. Your final score is ${score}.`
        : `Congratulations! You've completed the game with a score of ${score}.`;
    tg.showAlert(message, function() {
        restartGame();
    });
            tg.BackButton.show();

        }

        // Restart the game
        function restartGame() {
    tg.BackButton.hide();
    initializeGame();
}

        // Implement touch drag and drop functionality
        function implementTouchDragDrop() {
            let isDragging = false;
            let startX, startY;
            let originalX, originalY;

            currentCard.addEventListener('touchstart', handleTouchStart, { passive: false });
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd);

            function handleTouchStart(e) {
                if (!currentCard.draggable) return;
                isDragging = true;
                e.preventDefault(); // Prevent scrolling when starting drag
                const touch = e.touches[0];
                startX = touch.clientX - currentCard.offsetLeft;
                startY = touch.clientY - currentCard.offsetTop;
                originalX = currentCard.offsetLeft;
                originalY = currentCard.offsetTop;
                currentCard.style.zIndex = '1000';
            }

            function handleTouchMove(e) {
                if (!isDragging) return;
                e.preventDefault(); // Prevent scrolling during drag
                const touch = e.touches[0];
                let newX = touch.clientX - startX;
                let newY = touch.clientY - startY;

                currentCard.style.position = 'fixed';
                currentCard.style.left = newX + 'px';
                currentCard.style.top = newY + 'px';

                const afterElement = getDragAfterElement(timeline, touch.clientX);
                updateCardPositions(afterElement);

                placementIndicator.style.display = 'block';
                if (afterElement) {
                    timeline.insertBefore(placementIndicator, afterElement);
                } else {
                    timeline.appendChild(placementIndicator);
                }
            }

            function handleTouchEnd(e) {
                if (!isDragging) return;
                isDragging = false;
                currentCard.style.zIndex = '';
                placementIndicator.style.display = 'none';

                const touch = e.changedTouches[0];
                const dropTarget = document.elementFromPoint(touch.clientX, touch.clientY);

                if (timeline.contains(dropTarget)) {
                    handleDrop(createTouchDropEvent(touch));
                } else {
                    resetCurrentCardPosition();
                }

                resetCardPositions();
            }

            function createTouchDropEvent(touch) {
                return {
                    preventDefault: () => { },
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    dataTransfer: {
                        getData: () => 'current-card'
                    }
                };
            }

            function resetCurrentCardPosition() {
                currentCard.style.position = 'static';
                currentCard.style.left = '';
                currentCard.style.top = '';
            }
        }

        // Reset current card position
        function resetCurrentCardPosition() {
            currentCard.style.position = 'static';
            currentCard.style.left = '';
            currentCard.style.top = '';
        }

        // Event Listeners
        drawCardButton.addEventListener('click', drawCard);
        currentCard.addEventListener('dragstart', handleDragStart);
        currentCard.addEventListener('dragend', handleDragEnd);
        timeline.addEventListener('dragover', handleDragOver);
        timeline.addEventListener('dragleave', handleDragLeave);
        timeline.addEventListener('drop', handleDrop);
        restartGameButton.addEventListener('click', restartGame);



        // Initialize the game
        initializeGame();
        implementTouchDragDrop();</script>

</body>

</html>